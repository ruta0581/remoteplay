<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Client</title>
  <meta charset="utf-8">
  <style>
    #remoteVideo {
      width: 100%;
      max-width: 1280px;
      height: auto;
      background: #222;
      display: block;
      margin: 1em auto;
    }
    #ctrl {
      text-align: center;
      margin: 1em;
    }
	  #connectBtn {
    font-size: 1.8em;
    padding: 12px 54px;
    margin-top: 10px;
  }
  </style>
</head>
<body>
  <video id="remoteVideo" autoplay playsinline></video>
<div id="ctrl">
  <input id="playerName" placeholder="åå‰ (æœ€å¤§8æ–‡å­—)" maxlength="8" style="width: 400px; margin-bottom: 8px;"><br>
  <input id="wssUrl" placeholder="wss://..." style="width: 400px; margin-bottom: 8px;"><br>
  <div style="display: flex; align-items: center; justify-content: center;">
    <select id="gamepadSelect" style="width: 387px;">
      <option>ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰æœªæ¤œå‡º</option>
    </select>
    <span id="inputIndicator" style="
      display:inline-block;
      width:12px;
      height:12px;
      margin-left:8px;
      border-radius:6px;
      background:#888;
      border:1px solid #444;
    "></span>
  </div>
  <br>
  <button id="connectBtn" onclick="toggleConnection()">æ¥ç¶š</button>
</div>
<script>
let pc = null, ws = null, clientId = null;
let dataChannel = null, dcKeepAliveInterval = null;
let wsPingInterval = null;
let connected = false;
let lastInputTime = performance.now();
let lastVideoTimestamp = null;     // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å—ä¿¡ã—ãŸæ˜ åƒé€ä¿¡æ™‚åˆ»ï¼ˆç§’ï¼‰
let videoStartTimestamp = null;    // æ˜ åƒå†ç”Ÿé–‹å§‹æ™‚ã®ã‚µãƒ¼ãƒãƒ¼æ™‚åˆ»ï¼ˆç§’ï¼‰
let videoStartPerfTime = null;     // æ˜ åƒå†ç”Ÿé–‹å§‹æ™‚ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ™‚åˆ»ï¼ˆperformance.nowï¼‰
let syncIntervalId = null;
let isResetting = false;

function createPeerConnection() {
  const newPc = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  });

newPc.ontrack = e => {
  document.getElementById("remoteVideo").srcObject = e.streams[0];
  videoStartTimestamp = null;
  videoStartPerfTime = null;
  lastVideoTimestamp = null;
  // clockOffsetã¯æ®‹ã—ã¦OK
};

  newPc.ondatachannel = (event) => {
    dataChannel = event.channel;
    dataChannel.binaryType = "arraybuffer";

    dataChannel.onopen = () => {
      lastInputTime = performance.now();
      dcKeepAliveInterval = setInterval(() => {
        if (dataChannel.readyState === "open") {
          dataChannel.send(new Uint8Array([0]));
        }
      }, 5000);
      startGamepadPolling();
      startSyncWatchdog();
    };

dataChannel.onmessage = (e) => {
  const buf = new Uint8Array(e.data);
  if (buf.length === 1 && buf[0] === 0) return;
  if (buf[0] === 1 && buf.length === 5) {
    const ts = buf[1] | (buf[2] << 8) | (buf[3] << 16) | (buf[4] << 24);
    lastVideoTimestamp = ts;
    if (clockOffset === null) {
      clockOffset = (Date.now() / 1000) - ts;
    }
    if (
      videoStartTimestamp === null &&
      video &&
      !video.paused &&
      video.readyState >= 2
    ) {
      videoStartTimestamp = lastVideoTimestamp;
      videoStartPerfTime = performance.now();
      //console.log("åŸºæº–ã‚»ãƒƒãƒˆ ts=", videoStartTimestamp);
      if (!syncIntervalId) startSyncWatchdog();
    }
  }
};


  };

  return newPc;
}

function closePeerConnection() {
  if (pc) {
    pc.ontrack = null;
    pc.onicecandidate = null;
    pc.ondatachannel = null;
    pc.close();
    pc = null;
  }
  if (dataChannel && dcKeepAliveInterval) {
    clearInterval(dcKeepAliveInterval);
    dcKeepAliveInterval = null;
  }
  // â˜… ã“ã“ã§åŸºæº–ã‚‚ãƒªã‚»ãƒƒãƒˆ
  videoStartTimestamp = null;
  videoStartPerfTime = null;
  if (syncIntervalId) {
    clearInterval(syncIntervalId);
    syncIntervalId = null;
  }
}


function connect() {
  const url = document.getElementById("wssUrl").value;
  if (!/^wss:\/\/.+/.test(url)) {
    alert("æ­£ã—ã„WSSã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
    return;
  }

  const gamepadSelect = document.getElementById("gamepadSelect");
  if (!gamepadSelect.value || gamepadSelect.value === "ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰æœªæ¤œå‡º") {
    alert("ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã¾ã›ã‚“");
    return;
  }
  if (ws && ws.readyState === WebSocket.OPEN) ws.close();
  closePeerConnection();

  if (wsPingInterval) {
    clearInterval(wsPingInterval);
    wsPingInterval = null;
  }

  ws = new WebSocket(url);
  pc = createPeerConnection();
  let candidateQueue = [];

ws.onopen = () => {
  connected = true;
  updateButton();
  ws.send(JSON.stringify({ role: "client" }));

  // åå‰ã‚’é€ä¿¡ï¼ˆæœ€å¤§8æ–‡å­—ï¼‰
  const nameInput = document.getElementById("playerName");
  const name = nameInput?.value?.slice(0, 8) || "åç„¡ã—";
  ws.send(JSON.stringify({ type: "name", name }));

  wsPingInterval = setInterval(() => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "ping" }));
    }
  }, 5000);
};



ws.onmessage = async ({ data }) => {
  const msg = JSON.parse(data);

  if (msg.type === "pong") return;

  if (msg.type === "reconnect") {
    reconnect();
    return;
  }

if (msg.type === "force-disconnect") {
  console.log("å—ä¿¡: force-disconnect", msg.clientId, clientId);
  if (!msg.clientId || msg.clientId == clientId) {
    console.log("åˆ‡æ–­æŒ‡ç¤ºã‚’å—ä¿¡");
    toggleConnection();
  }
  return;
}



  if (msg.type === "client-id") {
    clientId = msg.clientId;
    ws.send(JSON.stringify({ type: "request-offer", clientId }));
  }
    if (msg.type === "offer" && msg.clientId === clientId) {
      // PeerConnectionã‚’ä½œã‚Šç›´ã—
      closePeerConnection();
      pc = createPeerConnection();

      candidateQueue = [];

      await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
      for (const candidate of candidateQueue) {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      }
      candidateQueue = [];
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({ type: "answer", answer, clientId }));
    } else if (msg.type === "candidate" && msg.clientId === clientId) {
      if (!pc.remoteDescription || !pc.remoteDescription.type) {
        candidateQueue.push(msg.candidate);
      } else {
        await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
      }
    }
  };

  ws.onclose = () => {
    connected = false;
    updateButton();
    document.getElementById("remoteVideo").srcObject = null;
    closePeerConnection();
    if (wsPingInterval) {
      clearInterval(wsPingInterval);
      wsPingInterval = null;
    }
  };
}

function reconnect() {
  // å†æ¥ç¶šã¯ä¸€åº¦åˆ‡æ–­ã—ã¦ã‹ã‚‰å†åº¦ connect()
  if (ws && ws.readyState === WebSocket.OPEN) ws.close();
  setTimeout(connect, 300); // å°‘ã—é…å»¶ã—ã¦å†æ¥ç¶š
}

// UIã®ãƒœã‚¿ãƒ³è¡¨ç¤ºã‚’æ›´æ–°
function updateButton() {
  const btn = document.getElementById("connectBtn");
  if (connected) {
    btn.textContent = "åˆ‡æ–­";
  } else {
    btn.textContent = "æ¥ç¶š";
  }
}

// ãƒœã‚¿ãƒ³å‹•ä½œã‚’ãƒˆã‚°ãƒ«
function toggleConnection() {
  if (connected) {
    if (ws) ws.close();
    closePeerConnection();
    document.getElementById("remoteVideo").srcObject = null;
    connected = false;
    updateButton();
    videoStartTimestamp = null;
    videoStartPerfTime = null;
    // â˜…
    if (syncIntervalId) {
      clearInterval(syncIntervalId);
      syncIntervalId = null;
    }
  } else {
    connect();
  }
}



// æ˜ åƒã‚¯ãƒªãƒƒã‚¯ã§åœæ­¢ã—ãªã„ã‚ˆã†ã«
const remoteVideo = document.getElementById("remoteVideo");
remoteVideo.addEventListener('pause', (e) => {
  // ä¸€æ™‚åœæ­¢ã•ã‚ŒãŸã‚‰å³å†ç”Ÿå†é–‹
  remoteVideo.play();
});

// ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã®å…¨ç”»é¢ã‚„éŸ³é‡å¤‰æ›´ç­‰ã¯controlsã®ã¾ã¾OK
function startGamepadPolling() {
  let lastButtonStates = [];
  let lastAxes = [];
  const indicator = document.getElementById("inputIndicator");

  function updateIndicator() {
    const now = performance.now();
    const elapsed = now - lastInputTime;
    indicator.style.background = (elapsed < 200) ? "#0f0" : "#888";
  }

  function mapToXInput(gamepad) {
    const rawButtons = gamepad.buttons.map(b => b.value);
    const buttons = [
      rawButtons[0] > 0.1 ? 1 : 0,  // A
      rawButtons[1] > 0.1 ? 1 : 0,  // B
      rawButtons[2] > 0.1 ? 1 : 0,  // X
      rawButtons[3] > 0.1 ? 1 : 0,  // Y
      rawButtons[4] > 0.1 ? 1 : 0,  // LB
      rawButtons[5] > 0.1 ? 1 : 0,  // RB
      rawButtons[8] > 0.1 ? 1 : 0,  // BACK
      rawButtons[9] > 0.1 ? 1 : 0,  // START
      rawButtons[10] > 0.1 ? 1 : 0, // LTHUMB
      rawButtons[11] > 0.1 ? 1 : 0, // RTHUMB

      // D-Padï¼šPOVè»¸ or buttons[12-15] ã«ã‚ˆã£ã¦èª¿æ•´å¯èƒ½
      rawButtons[12] > 0.1 ? 1 : 0, // UP
      rawButtons[13] > 0.1 ? 1 : 0, // DOWN
      rawButtons[14] > 0.1 ? 1 : 0, // LEFT
      rawButtons[15] > 0.1 ? 1 : 0  // RIGHT
    ];
    return buttons;
  }

  function poll() {
    if (selectedPadIndex === null) return;
    const gamepad = navigator.getGamepads()[selectedPadIndex];
    if (gamepad && dataChannel && dataChannel.readyState === "open") {
      const buttons = mapToXInput(gamepad);

      const axesScaled = gamepad.axes.slice(0, 4).map(a => Math.round((a + 1) * 127.5));
      const analogTriggers = [
        Math.round((gamepad.buttons[6]?.value ?? 0) * 255), // LT
        Math.round((gamepad.buttons[7]?.value ?? 0) * 255)  // RT
      ];
      const axesCombined = axesScaled.concat(analogTriggers);

      const buttonChanged = lastButtonStates.length !== buttons.length ||
                            buttons.some((v, i) => v !== lastButtonStates[i]);
      const axesChanged = lastAxes.length !== axesCombined.length ||
                          axesCombined.some((v, i) => v !== lastAxes[i]);
if (buttonChanged || axesChanged) {
  lastInputTime = performance.now();

  // ãƒã‚¤ãƒŠãƒªæ§‹é€ : [0][14ãƒœã‚¿ãƒ³][6è»¸][ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—: 4byte(ms)]
  const buffer = new Uint8Array(1 + 14 + 6 + 4);
  buffer[0] = 0; // type = 0 = gamepad

  // buttons (14 x 1byte)
  for (let i = 0; i < 14; i++) {
    buffer[1 + i] = buttons[i];
  }

  // axes (6 x 1byte)
  for (let i = 0; i < 6; i++) {
    buffer[15 + i] = axesCombined[i];
  }

  // timestamp (uint32, little-endian)
  const ts = Date.now();
  buffer[21] = ts & 0xFF;
  buffer[22] = (ts >> 8) & 0xFF;
  buffer[23] = (ts >> 16) & 0xFF;
  buffer[24] = (ts >> 24) & 0xFF;

  dataChannel.send(buffer);

  lastButtonStates = buttons;
  lastAxes = axesCombined;
}

    }
    updateIndicator();
    requestAnimationFrame(poll);
  }

  updateIndicator();
  requestAnimationFrame(poll);
}


let selectedPadIndex = null;
let lastButtonStates = [];

function updateGamepadList() {
  const gamepads = navigator.getGamepads();
  const select = document.getElementById("gamepadSelect");
  select.innerHTML = "";
  for (let i = 0; i < gamepads.length; i++) {
    const gp = gamepads[i];
    if (gp) {
      const opt = document.createElement("option");
      opt.value = i;
      opt.textContent = `#${i}: ${gp.id}`;
      select.appendChild(opt);
    }
  }
  if (select.options.length > 0 && selectedPadIndex === null) {
  selectedPadIndex = parseInt(select.options[0].value);
  select.value = selectedPadIndex;
  lastButtonStates = [];
  //console.log("ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé¸æŠ:", selectedPadIndex);
}
}
window.addEventListener("gamepadconnected", updateGamepadList);
window.addEventListener("gamepaddisconnected", updateGamepadList);

document.getElementById("gamepadSelect").addEventListener("change", (e) => {
  selectedPadIndex = parseInt(e.target.value);
  lastButtonStates = [];
});
/*window.addEventListener("gamepadconnected", (e) => {
  console.log("Gamepad connected:", e.gamepad);
});*/
function updateButton() {
  const btn = document.getElementById("connectBtn");
  const locked = connected;

  btn.textContent = connected ? "åˆ‡æ–­" : "æ¥ç¶š";

  // æ¥ç¶šä¸­ã¯å…¥åŠ›ãƒ­ãƒƒã‚¯
  document.getElementById("playerName").disabled = locked;
  document.getElementById("wssUrl").disabled = locked;
  document.getElementById("gamepadSelect").disabled = locked;

  // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰æ¥ç¶šæ¤œå‡ºã®æœ‰åŠ¹/ç„¡åŠ¹
  if (locked) {
    window.removeEventListener("gamepadconnected", updateGamepadList);
    window.removeEventListener("gamepaddisconnected", updateGamepadList);
  } else {
    window.addEventListener("gamepadconnected", updateGamepadList);
    window.addEventListener("gamepaddisconnected", updateGamepadList);
  }
}
// æ—¢å­˜ã® video å–å¾—ã®ç›´å¾Œ
const video = document.getElementById("remoteVideo");

// --- ã“ã“ã‹ã‚‰ç›£è¦–è¿½åŠ  ---
let videoStuckTimeout = null;
function monitorVideoStuck() {
  let lastTime = video.currentTime;
  clearTimeout(videoStuckTimeout);
  videoStuckTimeout = setTimeout(() => {
    // 4ç§’é–“currentTimeãŒé€²ã‚“ã§ã„ãªã„ã€ã¾ãŸã¯readyState<2
    if (video.currentTime === lastTime || video.readyState < 2) {
      console.warn("âš ï¸ æ˜ åƒãŒåœæ­¢ or æœªå—ä¿¡ã€‚è‡ªå‹•å†åŒæœŸ");
      // è»½ã„å†åŒæœŸï¼ˆåŸºæº–å€¤ã‚¯ãƒªã‚¢ã§watchdogãŒè‡ªå‹•å†åŒæœŸåˆ¤æ–­ï¼‰
      videoStartTimestamp = null;
      videoStartPerfTime = null;
      // å¿…è¦ã«å¿œã˜ã¦ã‚‚ã£ã¨å¼·ã„å¾©å¸°ï¼ˆä¾‹ï¼šå†æ¥ç¶šï¼‰
      // toggleConnection();
    }
    monitorVideoStuck(); // ãƒ«ãƒ¼ãƒ—ç¶™ç¶š
  }, 4000);
}
video.addEventListener("play", monitorVideoStuck);
// --- ã“ã“ã¾ã§ ---


video.addEventListener("play", () => {
  if (!syncIntervalId) startSyncWatchdog();
});

let clockOffset = null; // ã‚µãƒ¼ãƒãƒ¼ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé–“ã®æ™‚è¨ˆå·®

function startSyncWatchdog() {
  if (syncIntervalId) clearInterval(syncIntervalId);
  let lastResetTime = 0;
  syncIntervalId = setInterval(() => {
    if (!video || !video.srcObject) return;
    const now = performance.now();
    const inputElapsed = now - lastInputTime;
    if (videoStartTimestamp === null || videoStartPerfTime === null || clockOffset === null) return;

    const elapsed = (now - videoStartPerfTime) / 1000;
    const expectedServerNow = videoStartTimestamp + elapsed;
    const actualServerNow = (Date.now() / 1000) - clockOffset;
    const rawDelay = actualServerNow - expectedServerNow;
    if (Math.abs(rawDelay) > 5) return; // æ¥µç«¯ãªå€¤ã¯ç„¡è¦–

    const streamDelay = Math.max(0, rawDelay);
    console.log("ğŸ“Š streamDelay =", streamDelay.toFixed(3));

    const shouldReset =
      (inputElapsed >= 1000 && streamDelay >= 0.5) ||
      (streamDelay >= 1.0);

    if (shouldReset && now - lastResetTime >= 10000 && !isResetting) {
      isResetting = true;
      try {
        const currentTime = video.currentTime;
        video.pause();
        video.currentTime = Math.max(0, currentTime - 0.1);
        video.addEventListener("seeked", () => {
          video.play();
          // ã“ã“ã§å†åº¦åŸºæº–ã‚’ã‚¯ãƒªã‚¢
          videoStartTimestamp = null;
          videoStartPerfTime = null;
          lastResetTime = performance.now();
          isResetting = false;
        }, { once: true });
      } catch (e) { isResetting = false; }
    }
  }, 500);
}
</script>
</body>
</html>
