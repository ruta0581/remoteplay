const path = require('path');
const wrtc = require('wrtc');
const WebSocket = require('ws');
const ViGEmClient = require("vigemclient");
const express = require('express');

const client = new ViGEmClient();
client.connect();

const MAX_CLIENTS = 4;
const clients = new Map();

let ninjaURL = "";
let ninjaViewId = "";

let wsServer = null;
let wsServerActive = false;

const logBuffer = [];
function log(msg) {
    const time = new Date().toLocaleTimeString();
    logBuffer.push(`[${time}] ${msg}`);
    if (logBuffer.length > 50) logBuffer.shift();
    console.log(msg);
}

function generateClientId(len = 5) {
    return Math.random().toString(36).slice(2, 2 + len);
}

// ----- Express API -----
const app = express();
const PORT = 8081;
app.use(express.static(path.join(__dirname, 'public')));

app.get('/api/status', (req, res) => {
    res.json({
        ninjaViewId,
        clientCount: clients.size,
        wsActive: wsServerActive,
        clients: Array.from(clients.values()).map(c => ({
            name: c.name,
            btns: c.lastInput?.btns || {},
            active: c.lastInput?.active || false,
            clientId: c.clientId,
            deadzoneL: c.deadzoneL ?? 5,
            deadzoneR: c.deadzoneR ?? 5,
            swapABXY: c.swapABXY ?? false,
            pingMs: c.pingMs ?? 0,  // ★ここを追加
        })),
        logs: logBuffer.slice(-30).reverse()
    });
});

// デッドゾーン＆ABXY入替設定API
app.post('/api/set_config', express.json(), (req, res) => {
    const { id, deadzoneL, deadzoneR, swapABXY } = req.body;
    for (const c of clients.values()) {
        if (c.clientId === id) {
            if (deadzoneL !== undefined) c.deadzoneL = Math.max(0, Math.min(100, parseInt(deadzoneL)));
            if (deadzoneR !== undefined) c.deadzoneR = Math.max(0, Math.min(100, parseInt(deadzoneR)));
            if (swapABXY !== undefined) c.swapABXY = !!swapABXY;
            break;
        }
    }
    res.json({ success: true });
});

// ninjaURLセットAPI
app.post('/api/set_ninja', express.json(), (req, res) => {
    const url = req.body.url || "";
    if (!url) {
        ninjaURL = "";
        ninjaViewId = "";
        for (const c of clients.values()) {
            if (c.dc && c.dc.readyState === 1)
                c.dc.send(JSON.stringify({ type: "ninja_id", id: "" }));
        }
        log("[ninja] URLリセット");
        return res.json({ success: true, viewId: "" });
    }
    try {
        const u = new URL(url);
        ninjaURL = url;
        ninjaViewId = u.searchParams.get("view") || u.pathname.replace(/^\//, "");
        for (const c of clients.values()) {
            if (c.dc && c.dc.readyState === 1)
                c.dc.send(JSON.stringify({ type: "ninja_id", id: ninjaViewId }));
        }
        log("[ninja] URL更新: " + url + " (view=" + ninjaViewId + ")");
        res.json({ success: true, viewId: ninjaViewId });
    } catch {
        res.json({ success: false, error: "不正なURLです" });
    }
});

// サーバー起動・停止API
app.post('/api/start_server', (req, res) => {
    if (!wsServerActive) startWSServer();
    res.json({ success: true });
});
app.post('/api/stop_server', (req, res) => {
    stopWSServer();
    res.json({ success: true });
});

// 個別切断（管理IDで指定）
app.post('/api/kick', express.json(), (req, res) => {
    const { id } = req.body; // clientId
    let found = false;
    for (const [ws, c] of clients) {
        if (c.clientId === id) {
            try {
                if (c.dc && c.dc.readyState === "open") {
                    c.dc.send(JSON.stringify({ type: "disconnect" }));
                }
            } catch (e) { log("send disconnect err: " + e.message); }
            setTimeout(() => {
                try { ws.close(); } catch (e) {}
                if (c.controller) try { c.controller.disconnect(); } catch (e) {}
            }, 100);
            found = true;
            log(`[kick] clientId=${id} 個別切断`);
            break;
        }
    }
    res.json({ success: found });
});

// ----- WebSocket/WebRTC サーバー -----
function startWSServer() {
    if (wsServerActive) return;
    wsServer = new WebSocket.Server({ port: 8080, path: '/ws' });
    wsServerActive = true;
    log('WebSocketサーバー開始: ws://0.0.0.0:8080/ws');

    wsServer.on('connection', async (ws, req) => {
        if (clients.size >= MAX_CLIENTS) {
            ws.send(JSON.stringify({ type: "error", reason: "Max clients reached (4)" }));
            ws.close();
            log(`[拒否] クライアント上限(4)超過`);
            return;
        }
        const clientId = generateClientId();
        log(`[ID割当] 新規クライアント: id=${clientId} IP=${req.socket?.remoteAddress || ""}`);

        const peer = new wrtc.RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        const dc = peer.createDataChannel("data", {
		ordered: false,
		maxRetransmits: 0
		});

        let controller = null;
        let name = "";
        let id = "";
        let lastInput = { btns: {}, active: false };
        // 設定値初期化
        let deadzoneL = 5, deadzoneR = 5, swapABXY = false;
        // ping関連
        let pingMs = 0, pingSendTime = 0;

        dc.onopen = () => {
            dc.send(JSON.stringify({ type: "ninja_id", id: ninjaViewId || "" }));
            try {
                controller = client.createX360Controller();
                controller.connect();
                clients.set(ws, { peer, dc, controller, name, id, lastInput, clientId, deadzoneL, deadzoneR, swapABXY, pingMs });
                log(`[接続] クライアント追加: id=${clientId} 現在${clients.size}人`);
            } catch (e) {
                ws.send(JSON.stringify({ type: "error", reason: "ViGEm error: " + e.message }));
                ws.close();
                log("[ViGEm error] " + e.message);
            }
            // ★ ping計測ループ開始
            function sendPing() {
                if (dc.readyState === "open") {
                    pingSendTime = Date.now();
                    dc.send(JSON.stringify({ type: "ping", ts: pingSendTime }));
                    setTimeout(sendPing, 2500); // 2.5秒ごと
                }
            }
            sendPing();
        };

        dc.onclose = () => {
            if (controller) controller.disconnect();
            clients.delete(ws);
            log(`[切断(DataChannel)] クライアント削除 残り${clients.size}人`);
        };

        dc.onmessage = (msg) => {
            try {
                let buf = null;
                if (msg.data instanceof Buffer) buf = msg.data;
                else if (msg.data instanceof ArrayBuffer) buf = Buffer.from(new Uint8Array(msg.data));
                else if (msg.data instanceof Uint8Array) buf = Buffer.from(msg.data);
                else if (typeof msg.data === "string") {
                    try {
                        const parsed = JSON.parse(msg.data);
                        // --- ★ ここでpong応答を受信
                        if (parsed.type === "pong" && parsed.ts && pingSendTime) {
                            pingMs = Math.max(0, Date.now() - parsed.ts);
                            if (clients.has(ws)) clients.get(ws).pingMs = pingMs;
                            return;
                        }
if (parsed.type === "hello") {
    name = parsed.name || "";
    if (clients.has(ws)) {
        clients.get(ws).name = name;
    }
    log(`[hello] name=${name}`);
}
                    } catch {}
                    return;
                } else {
                    log('未知型:' + msg.data);
                    return;
                }
                if (!controller) return;

                // 設定値取得
                const c = clients.get(ws) || {};
                const dzL = c.deadzoneL ?? 5;
                const dzR = c.deadzoneR ?? 5;
                const swap = c.swapABXY ?? false;

                const btnBits = buf[0] | (buf[1] << 8);
                const convAxis = v => ((v / 127.5) - 1.0);
                function applyDeadzone(val, dz) {
                    return Math.abs(val) < dz/100 ? 0 : val;
                }
                let lx = convAxis(buf[2]);
                let ly = convAxis(buf[3]);
                let rx = convAxis(buf[4]);
                let ry = convAxis(buf[5]);
                lx = applyDeadzone(lx, dzL);
                ly = applyDeadzone(ly, dzL);
                rx = applyDeadzone(rx, dzR);
                ry = applyDeadzone(ry, dzR);

                const lt = buf[6] / 255;
                const rt = buf[7] / 255;

                // ABXY入替
                let btnA = !!(btnBits & (1 << 0)), btnB = !!(btnBits & (1 << 1)),
                    btnX = !!(btnBits & (1 << 2)), btnY = !!(btnBits & (1 << 3));
                if (swap) {
                    [btnA, btnB] = [btnB, btnA];
                    [btnX, btnY] = [btnY, btnX];
                }

lastInput.btns = {
    A: btnA,
    B: btnB,
    X: btnX,
    Y: btnY,
    START: !!(btnBits & (1 << 9)),
    BACK: !!(btnBits & (1 << 8)),
    LEFT_SHOULDER: !!(btnBits & (1 << 4)),
    RIGHT_SHOULDER: !!(btnBits & (1 << 5)),
    LEFT_THUMB: !!(btnBits & (1 << 6)),
    RIGHT_THUMB: !!(btnBits & (1 << 7)),
    UP: !!(btnBits & (1 << 12)),
    DOWN: !!(btnBits & (1 << 13)),
    LEFT: !!(btnBits & (1 << 14)),
    RIGHT: !!(btnBits & (1 << 15)),
    LT: lt > 0.1,
    RT: rt > 0.1
};

                const stickMoved = Math.abs(lx) > 0.1 || Math.abs(ly) > 0.1 || Math.abs(rx) > 0.1 || Math.abs(ry) > 0.1;
lastInput.active =Object.values(lastInput.btns).some(v => v) || stickMoved;
                if (clients.has(ws)) clients.get(ws).lastInput = lastInput;

                controller.button.A.setValue(btnA);
                controller.button.B.setValue(btnB);
                controller.button.X.setValue(btnX);
                controller.button.Y.setValue(btnY);
                controller.button.LEFT_SHOULDER.setValue(!!(btnBits & (1 << 4)));
                controller.button.RIGHT_SHOULDER.setValue(!!(btnBits & (1 << 5)));
                controller.button.LEFT_THUMB.setValue(!!(btnBits & (1 << 6)));
                controller.button.RIGHT_THUMB.setValue(!!(btnBits & (1 << 7)));
                controller.button.BACK.setValue(!!(btnBits & (1 << 8)));
                controller.button.START.setValue(!!(btnBits & (1 << 9)));

                let dpadHorz = 0.0, dpadVert = 0.0;
                if (btnBits & (1 << 12)) dpadVert += 1.0;
                if (btnBits & (1 << 13)) dpadVert -= 1.0;
                if (btnBits & (1 << 14)) dpadHorz -= 1.0;
                if (btnBits & (1 << 15)) dpadHorz += 1.0;
                controller.axis.dpadHorz.setValue(dpadHorz);
                controller.axis.dpadVert.setValue(dpadVert);

                controller.axis.leftX.setValue(lx);
                controller.axis.leftY.setValue(-ly);
                controller.axis.rightX.setValue(rx);
                controller.axis.rightY.setValue(-ry);
                controller.axis.leftTrigger.setValue(lt);
                controller.axis.rightTrigger.setValue(rt);

            } catch (e) {
                log('dc.onmessage error: ' + e.message);
            }
        };

        peer.onicecandidate = e => {
            if (e.candidate) ws.send(JSON.stringify({ type: "candidate", candidate: e.candidate }));
        };

        const offer = await peer.createOffer();
        await peer.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: "offer", offer }));

        ws.on('message', async (message) => {
            const msg = JSON.parse(message);
            if (msg.type === "answer") await peer.setRemoteDescription(msg.answer);
            else if (msg.type === "candidate") await peer.addIceCandidate(new wrtc.RTCIceCandidate(msg.candidate));
        });

        ws.on('close', () => {
            log(`[シグナリングWS切断] クライアントWebSocketが閉じられた`);
        });
    });
}

function stopWSServer() {
    if (!wsServerActive) return;
    for (const [ws, c] of clients) {
        try {
            if (c.dc && c.dc.readyState === "open") {
                c.dc.send(JSON.stringify({ type: "disconnect" }));
            }
        } catch (e) { log("send disconnect err: " + e.message); }
        setTimeout(() => {
            try { ws.close(); } catch (e) {}
            if (c.controller) try { c.controller.disconnect(); } catch (e) {}
        }, 100);
    }
    clients.clear();
    try { wsServer.close(() => log("[ws] サーバー停止")); } catch(e){}
    wsServerActive = false;
}

app.listen(PORT, () => {
    log(`サーバーGUI: http://localhost:${PORT}/server.html`);
    setTimeout(() => {
        // Microsoft Edgeを小ウインドウ＋アプリモードで自動起動
        const url = `http://localhost:${PORT}/server.html`;
        require('child_process').exec(
            `start msedge --new-window --window-size=640,480 --app=${url}`
        );
    }, 500);
});
app.post('/api/exit', (req, res) => {
    res.json({ success: true });
    setTimeout(() => process.exit(0), 200);
});
