<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>RemotePlay WebRTC Client</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0 1.5rem 2rem;
      background: #0f0f10;
      color: #f1f1f2;
    }
    h1 {
      font-size: 1.5rem;
      margin-top: 1.5rem;
      margin-bottom: 1rem;
    }
    #remoteVideo {
      width: 100%;
      max-width: 960px;
      border-radius: 8px;
      background: #1e1e22;
      border: 1px solid #2b2b30;
      margin: 1rem auto;
      display: block;
    }
    .panel {
      max-width: 960px;
      margin: 0 auto;
      background: #18181c;
      border: 1px solid #2a2a30;
      border-radius: 12px;
      padding: 1.2rem 1.4rem;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
    }
    .panel label {
      display: block;
      margin-bottom: 0.35rem;
      font-weight: 600;
    }
    .panel input,
    .panel select {
      width: 100%;
      padding: 0.55rem 0.7rem;
      border-radius: 8px;
      border: 1px solid #3c3c44;
      background: #111116;
      color: inherit;
      margin-bottom: 0.9rem;
    }
    .panel input:focus,
    .panel select:focus {
      outline: 2px solid #4f8cff;
      outline-offset: 2px;
    }
    button.primary {
      width: 100%;
      padding: 0.75rem;
      border-radius: 10px;
      border: none;
      font-size: 1.1rem;
      font-weight: 600;
      margin-top: 0.5rem;
      background: linear-gradient(135deg, #4f8cff, #7851ff);
      color: white;
      cursor: pointer;
    }
    button.primary:disabled {
      background: #3b3b40;
      cursor: not-allowed;
    }
    .status-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      margin-top: 0.8rem;
      font-size: 0.95rem;
      color: #c9c9d3;
    }
    .status-row span {
      background: #121219;
      border-radius: 999px;
      padding: 0.35rem 0.75rem;
      border: 1px solid #2c2c34;
    }
    .gamepad-row {
      display: flex;
      align-items: center;
      gap: 0.8rem;
    }
    #inputIndicator {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #51515a;
      border: 1px solid #2d2d34;
      box-shadow: 0 0 0 2px rgba(79, 140, 255, 0.15);
    }
    a {
      color: #7aa8ff;
    }
    @media (max-width: 640px) {
      .gamepad-row {
        flex-direction: column;
        align-items: stretch;
      }
      button.primary {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>RemotePlay WebRTC クライアント</h1>
  <video id="remoteVideo" playsinline autoplay muted></video>
  <section class="panel">
    <label for="playerName">プレイヤー名 (8文字以内)</label>
    <input id="playerName" maxlength="8" placeholder="例: ゲスト" />

    <label for="wssUrl">ホストから共有された WSS URL</label>
    <input id="wssUrl" placeholder="wss://example.trycloudflare.com/ws" />

    <label for="gamepadSelect">送信するゲームパッド</label>
    <div class="gamepad-row">
      <select id="gamepadSelect">
        <option value="">ゲームパッド未検出</option>
      </select>
      <span id="inputIndicator"></span>
    </div>

    <button id="connectBtn" class="primary">接続する</button>

    <div class="status-row">
      <span id="connectionStatus">未接続</span>
      <span id="clientCount">接続中クライアント: 0</span>
      <span id="rttStatus">RTT: -</span>
    </div>

    <p style="margin-top:1.2rem; font-size:0.9rem; color:#b8b8c5;">
      ホストアプリで生成された WSS URL を入力し、GitHub Pages 等で公開されている
      <code>cliant.html</code> 経由で視聴・入力を行えます。ゲームパッドは Chrome / Edge の最新バージョンでご利用ください。
    </p>
  </section>

  <script>
    const remoteVideo = document.getElementById("remoteVideo");
    const connectBtn = document.getElementById("connectBtn");
    const statusLabel = document.getElementById("connectionStatus");
    const clientCountLabel = document.getElementById("clientCount");
    const rttLabel = document.getElementById("rttStatus");
    const indicator = document.getElementById("inputIndicator");
    const gamepadSelect = document.getElementById("gamepadSelect");

    let ws = null;
    let pc = null;
    let dataChannel = null;
    let clientId = null;
    let pingInterval = null;
    let connected = false;
    let pollingGamepad = false;
    let lastPayload = null;
    let lastInputAt = 0;

    const BUTTON_BITS = {
      A: 1 << 0,
      B: 1 << 1,
      X: 1 << 2,
      Y: 1 << 3,
      LB: 1 << 4,
      RB: 1 << 5,
      BACK: 1 << 6,
      START: 1 << 7,
      LS: 1 << 8,
      RS: 1 << 9,
      UP: 1 << 10,
      DOWN: 1 << 11,
      LEFT: 1 << 12,
      RIGHT: 1 << 13,
    };

    function updateStatusUi() {
      const connecting = ws && ws.readyState === WebSocket.CONNECTING;
      statusLabel.textContent = connected ? "接続中" : connecting ? "接続準備中" : "未接続";
      connectBtn.textContent = connecting
        ? "接続中..."
        : connected
        ? "切断する"
        : "接続する";
      connectBtn.disabled = connecting;
    }

    async function startPeerConnection() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });

      pc.ontrack = (event) => {
        if (event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
        }
      };

      pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "ice_candidate",
              candidate: event.candidate.candidate,
              sdp_mid: event.candidate.sdpMid ?? null,
              sdp_mline_index: event.candidate.sdpMLineIndex ?? null,
            })
          );
        }
      };

      pc.onconnectionstatechange = () => {
        if (pc.connectionState === "connected") {
          connected = true;
          updateStatusUi();
        }
        if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
          disconnect();
        }
      };

      dataChannel = pc.createDataChannel("input", { ordered: false });
      dataChannel.onopen = () => {
        startGamepadPolling();
      };
      dataChannel.onclose = () => {
        stopGamepadPolling();
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(
        JSON.stringify({
          type: "sdp_offer",
          sdp: offer.sdp,
        })
      );
    }

    function handleWelcome(msg) {
      clientId = msg.client_id;
      startPeerConnection().catch((err) => {
        console.error("Failed to start WebRTC", err);
        alert("WebRTC の初期化に失敗しました: " + err.message);
        disconnect();
      });
      startPing();
    }

    function handleSdpAnswer(msg) {
      if (!pc) return;
      pc.setRemoteDescription(new RTCSessionDescription({ type: "answer", sdp: msg.sdp })).catch(
        (err) => {
          console.error("Failed to apply answer", err);
        }
      );
    }

    function handleIceCandidate(msg) {
      if (!pc) return;
      pc.addIceCandidate(
        new RTCIceCandidate({
          candidate: msg.candidate,
          sdpMid: msg.sdp_mid ?? undefined,
          sdpMLineIndex: msg.sdp_mline_index ?? undefined,
        })
      ).catch((err) => console.warn("ICE candidate error", err));
    }

    function handlePong(msg) {
      const now = Date.now();
      const latency = Math.max(0, now - Number(msg.timestamp || 0));
      rttLabel.textContent = `RTT: ${latency}ms`;
    }

    function handleStatus(msg) {
      if (typeof msg.connected_clients === "number") {
        clientCountLabel.textContent = `接続中クライアント: ${msg.connected_clients}`;
      }
    }

    function startPing() {
      stopPing();
      pingInterval = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "ping",
              timestamp: Date.now(),
            })
          );
        }
      }, 5000);
    }

    function stopPing() {
      if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
      }
    }

    function connect() {
      const url = document.getElementById("wssUrl").value.trim();
      if (!/^wss?:\/\//i.test(url)) {
        alert("正しい WSS アドレスを入力してください。");
        return;
      }

      if (ws) {
        ws.close();
        ws = null;
      }

      ws = new WebSocket(url);
      updateStatusUi();

      ws.onopen = () => {
        updateStatusUi();
        ws.send(
          JSON.stringify({
            type: "join",
            name: document.getElementById("playerName").value.trim() || "ゲスト",
          })
        );
      };

      ws.onmessage = (event) => {
        let msg;
        try {
          msg = JSON.parse(event.data);
        } catch (err) {
          console.warn("Invalid JSON", err);
          return;
        }

        switch (msg.type) {
          case "welcome":
            handleWelcome(msg);
            break;
          case "sdp_answer":
            handleSdpAnswer(msg);
            break;
          case "ice_candidate":
            handleIceCandidate(msg);
            break;
          case "pong":
            handlePong(msg);
            break;
          case "status":
            handleStatus(msg);
            break;
          case "error":
            alert(msg.message || "ホストからエラーが返されました");
            break;
          default:
            console.debug("Unknown message", msg);
        }
      };

      ws.onclose = () => {
        disconnect();
      };

      ws.onerror = (err) => {
        console.error("WebSocket error", err);
      };
    }

    function disconnect() {
      stopPing();
      stopGamepadPolling();
      if (ws) {
        try {
          ws.close();
        } catch (_) {}
        ws = null;
      }
      if (dataChannel) {
        try {
          dataChannel.close();
        } catch (_) {}
        dataChannel = null;
      }
      if (pc) {
        pc.getSenders().forEach((sender) => sender.track?.stop());
        pc.close();
        pc = null;
      }
      remoteVideo.srcObject = null;
      connected = false;
      clientId = null;
      clientCountLabel.textContent = "接続中クライアント: 0";
      rttLabel.textContent = "RTT: -";
      updateIndicator();
      updateStatusUi();
    }

    function buildInputPayload(gamepad) {
      const buttons = gamepad.buttons || [];
      const axes = gamepad.axes || [];
      let mask = 0;

      if (buttons[0]?.pressed) mask |= BUTTON_BITS.A;
      if (buttons[1]?.pressed) mask |= BUTTON_BITS.B;
      if (buttons[2]?.pressed) mask |= BUTTON_BITS.X;
      if (buttons[3]?.pressed) mask |= BUTTON_BITS.Y;
      if (buttons[4]?.pressed) mask |= BUTTON_BITS.LB;
      if (buttons[5]?.pressed) mask |= BUTTON_BITS.RB;
      if (buttons[8]?.pressed) mask |= BUTTON_BITS.BACK;
      if (buttons[9]?.pressed) mask |= BUTTON_BITS.START;
      if (buttons[10]?.pressed) mask |= BUTTON_BITS.LS;
      if (buttons[11]?.pressed) mask |= BUTTON_BITS.RS;
      if (buttons[12]?.pressed) mask |= BUTTON_BITS.UP;
      if (buttons[13]?.pressed) mask |= BUTTON_BITS.DOWN;
      if (buttons[14]?.pressed) mask |= BUTTON_BITS.LEFT;
      if (buttons[15]?.pressed) mask |= BUTTON_BITS.RIGHT;

      return {
        buttons: mask >>> 0,
        left_trigger: buttons[6]?.value ?? 0,
        right_trigger: buttons[7]?.value ?? 0,
        left_x: axes[0] ?? 0,
        left_y: -(axes[1] ?? 0),
        right_x: axes[2] ?? 0,
        right_y: -(axes[3] ?? 0),
      };
    }

    function payloadChanged(prev, next) {
      if (!prev) return true;
      if (prev.buttons !== next.buttons) return true;
      const fields = [
        "left_trigger",
        "right_trigger",
        "left_x",
        "left_y",
        "right_x",
        "right_y",
      ];
      return fields.some((key) => Math.abs(prev[key] - next[key]) > 0.01);
    }

    function pollGamepad() {
      if (!pollingGamepad) return;
      const index = Number(gamepadSelect.value);
      const pads = navigator.getGamepads();
      const gamepad = pads && pads[index];
      if (gamepad && dataChannel && dataChannel.readyState === "open") {
        const payload = buildInputPayload(gamepad);
        if (payloadChanged(lastPayload, payload)) {
          lastPayload = payload;
          dataChannel.send(JSON.stringify(payload));
          lastInputAt = performance.now();
        }
      }
      updateIndicator();
      requestAnimationFrame(pollGamepad);
    }

    function startGamepadPolling() {
      if (pollingGamepad) return;
      if (!gamepadSelect.value) return;
      pollingGamepad = true;
      lastPayload = null;
      requestAnimationFrame(pollGamepad);
    }

    function stopGamepadPolling() {
      pollingGamepad = false;
      lastPayload = null;
      updateIndicator();
    }

    function updateIndicator() {
      const elapsed = performance.now() - lastInputAt;
      indicator.style.background = elapsed < 200 ? "#30d158" : "#51515a";
    }

    function refreshGamepadList() {
      const pads = Array.from(navigator.getGamepads ? navigator.getGamepads() : []).filter(
        Boolean
      );
      const previous = gamepadSelect.value;
      gamepadSelect.innerHTML = "";
      if (!pads.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "ゲームパッド未検出";
        gamepadSelect.appendChild(opt);
      } else {
        pads.forEach((pad, idx) => {
          const opt = document.createElement("option");
          opt.value = String(idx);
          opt.textContent = pad.id || `Gamepad ${idx + 1}`;
          gamepadSelect.appendChild(opt);
        });
        if (pads[Number(previous)]) {
          gamepadSelect.value = previous;
        }
      }
      if (!gamepadSelect.value && pads.length) {
        gamepadSelect.value = "0";
      }
    }

    connectBtn.addEventListener("click", () => {
      if (connected || (pc && pc.connectionState === "connected")) {
        disconnect();
      } else {
        connect();
      }
    });

    gamepadSelect.addEventListener("change", () => {
      stopGamepadPolling();
      if (dataChannel && dataChannel.readyState === "open" && gamepadSelect.value) {
        startGamepadPolling();
      }
    });

    window.addEventListener("gamepadconnected", () => {
      refreshGamepadList();
      if (dataChannel && dataChannel.readyState === "open") {
        startGamepadPolling();
      }
    });

    window.addEventListener("gamepaddisconnected", () => {
      refreshGamepadList();
    });

    updateStatusUi();
    refreshGamepadList();
    updateIndicator();
  </script>
</body>
</html>
